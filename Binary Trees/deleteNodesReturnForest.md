### 1110. Delete Nodes And Return Forest
Given the root of a binary tree, each node in the tree has a distinct value.

After deleting all nodes with a value in to_delete, we are left with a forest (a disjoint union of trees).

Return the roots of the trees in the remaining forest.  You may return the result in any order.

Input: **root = [1,2,3,4,5,6,7]**, **to_delete = [3,5]**

Output: **[[1,2,null,4],[6],[7]]**

URL: https://leetcode.com/problems/delete-nodes-and-return-forest/

#### Strategy
To paraphrase the question, if we encounter a node that has a value matching to_delete param, we set this node's children as new trees, then in the old tree we set this node and all of it's children to ***null***. After traversing all of the nodes, we then return an array which contains the modified old tree, and all of the new trees generated by this alogrithm. 

I approached this question with a breadth-first algorithm with some recursion mixed in. First, we keep track of our root in a result array. As we traverse through the tree, every time a node satisfies the to_delete param, we will recursively call the same function on this node's two children. We then include the returned results as roots of the new trees in our result array, and we finally set the node to ***null***. 

#### Time/Space Complexity
Since we are traversing through all of the nodes in this tree, time complexity is ***O(N)*** . Since we will be storing the roots of all forests in our result array, space complexity is also ***O(N)***